# 벨만-포드 알고리즘 - 예제 (백준 11657 : 타임머신)

> ### 문제 설명

><p>N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 버스가 M개 있다. 각 버스는 A, B, C로 나타낼 수 있는데, A는 시작도시, B는 도착도시, C는 버스를 타고 이동하는데 걸리는 시간이다. 시간 C가 양수가 아닌 경우가 있다. C = 0인 경우는 순간 이동을 하는 경우, C < 0인 경우는 타임머신으로 시간을 되돌아가는 경우이다.</p>
>
><p>1번 도시에서 출발해서 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.</p>

> ### 입력 

><p>첫째 줄에 도시의 개수 N (1 ≤ N ≤ 500), 버스 노선의 개수 M (1 ≤ M ≤ 6,000)이 주어진다. 둘째 줄부터 M개의 줄에는 버스 노선의 정보 A, B, C (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)가 주어진다. </p>

> ### 출력 

> <p>만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다. 그렇지 않다면 N-1개 줄에 걸쳐 각 줄에 1번 도시에서 출발해 2번 도시, 3번 도시, ..., N번 도시로 가는 가장 빠른 시간을 순서대로 출력한다. 만약 해당 도시로 가는 경로가 없다면 대신 -1을 출력한다.</p>

## 문제 해설

전형적인 벨만-포드 알고리즘 예제이다.

음수 간선이 존재하고, 출력 조건에 명시되어 있는 "시간을 무한히 오래 전으로 되돌릴 수 있다"라는 서술에서 테스트 케이스에 음수 사이클이 존재할 수 있다는 것을 알 수 있다. 따라서 음수 사이클의 존재를 감지할 수 있는 벨만-포드 알고리즘을 사용해야 한다는 것을 파악할 수 있다.

### 문제 조건 초기화
먼저 도시의 개수와 버스 노선의 개수를 각각 v, e라는 변수명으로 받아 온다. (문제의 입력 조건에서는 각각 N과 M을 사용했지만, 그래프 문제에서는 노드와 간선에 해당하는 변수의 명칭을 각각 v와 e로 사용하여 혼동을 방지하는 것을 권장한다)

edges라는 변수명으로 빈 리스트를 만들고, 둘째 줄부터 e개의 줄까지 주어지는 버스 노선의 정보를 튜플로 만들어 저장한다.

distance라는 변수명으로 (v+1)만큼의 길이를 갖는 리스트를 만들고, 각 노드까지의 거리를 모두 무한대로 초기화한다. 본 정답 코드 예시에서는 무한대에 해당하는 값으로 ```float("inf")```를 사용하였다.

### 벨만-포드 알고리즘 구현

벨만 포드 알고리즘은 다익스트라 알고리즘과 다르게 **모든 간선**을 탐색하고, 이를 노드의 개수만큼 반복하므로, 이중 for 문으로 구현한다.

bellman_ford라는 함수를 만들고, 인자로 출발 도시의 노드 번호(start_node)를 받도록 한다.

출발 도시에서 자기 자신까지의 거리는 0이므로, distance[start_node] = 0 으로 설정한다.


#### 음수 사이클 체크
노드의 개수는 v이기 때문에, 우리는 보통 노드의 개수만큼 반복하고자 한다면 for문을 설정할 때 range(v)로 설정한다. 하지만 정답 코드를 보면 range의 값이 v+1으로 설정되어 있는 것을 확인할 수 있다. 이는 음수 사이클을 체크하기 위해 의도된 것이다.

전체 간선 탐색을 모든 노드에 대해 완료하고 나면, 

따라서 만약 v+1번째 사이클(i == v)에서 distance 리스트에 변화가 있는지 확인한다면, 음수 사이클이 존재하는 것을 체크하여 -1을 출력하도록 조건문을 설정할 수 있다. 




## 정답 코드
```python
v, e = map(int, input().split())
edges = []
distance = [float("inf")] * (v + 1)
for _ in range(e):
    edges.append(tuple(map(int, input().split())))


def bellman_ford(start_node):
    distance[start_node] = 0
    for i in range(v + 1):
        for start, end, weight in edges:
            if distance[start] == float("inf"):
                continue
            if distance[end] > distance[start] + weight:
                distance[end] = distance[start] + weight
                if i == v:
                    print(-1)
                    return

    for i in range(2, len(distance)):
        if distance[i] == float("inf"):
            print(-1)
        else:
            print(distance[i])

bellman_ford(1)
```


# 위상 정렬 - 예제 (백준 2252 : 줄 세우기)

>### 문제 설명

><p>N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.</p>
>
><p>일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.</p>

>### 입력 

><p>첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 횟수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.</p>
>
><p>학생들의 번호는 1번부터 N번이다.</p>

>### 출력 

><p>첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.</p>

>### 테스트 케이스
>|예제 입력 1|예제 출력 1
>|----|----
>|3 2<br>1 3<br>2 3|1 2 3<br> <br> <br>
>
>|예제 입력 2|예제 출력 2
>|----|----
>|4 2<br>4 2<br>3 1|4 2 3 1<br> <br> <br>

---


## 문제 해설
학생 A가 학생 B보다 앞에 서야 한다는 조건은 A가 먼저 줄을 서야만 B가 줄을 설 수 있다는 의미이므로, 위상 정렬을 이용할 수 있다는 것을 알 수 있다.
출력 조건에 답이 여러 가지일 수 있다는 사실을 명시하고 있다.


### 문제 조건 초기화
indegree 테이블을 만들고, 전부 0으로 초기화한다.<br>
graph 테이블에 각 노드별로 간선 정보를 저장한다. 이 때, 도착 노드(end) 진입 차수를 1씩 늘려준다.

### 위상 정렬 구현
큐를 이용해서 구현한다. 진입 차수가 0인 노드를 큐에 넣고, 큐에서 노드를 하나씩 빼서 해당 노드와 연결된 간선을 지운다. 이후에 새롭게 진입 차수가 0이 된 노드를 큐에 넣는다. 이 과정을 반복한다.


## 정답 코드
```python
from collections import deque

n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]
indegree = [0] * (n + 1)

for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    indegree[b] += 1


result = []
queue = deque()

for i in range(1, n + 1):
    if indegree[i] == 0:
        queue.append(i)

while queue:
    now = queue.popleft()
    result.append(now)
    for i in graph[now]:
        indegree[i] -= 1
        if indegree[i] == 0:
            queue.append(i)


for i in result:
    print(i, end=" ")

```