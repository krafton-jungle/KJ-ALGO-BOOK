<script type="text/x-mathjax-config">  
        MathJax.Hub.Config({  
        tex2jax: {  
	        inlineMath: [ ['$','$'], ["\\(","\\)"] ],  
	        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],  
	        processEscapes: true  
        },  
        });  
</script>  
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">  
</script>   
  
<script> MathJax.Hub.Queue(["Typeset",MathJax.Hub]); </script>  

# 동적 프로그래밍 구현

동적 프로그래밍을 사용할 수 있는 조건을 만족했다면, 이제 구현을 해야할 차례이다. n번째 피보나치 수를 구하는 문제를 각 단계별로 해결해보자.

## (1) 최적해의 구조의 특징을 찾는다
이 단계는 최적 부분 구조를 파악하는 단계이다. 어떠한 부분 문제로 나뉠 수 있는지, 그리고 부분 문제의 최적해를 어떻게 조합해야 전체 문제의 최적해를 구할 수 있는지를 파악한다. 피보나치 문제의 경우 아래와 같이 파악할 수 있다.

- 부분 문제: n번째 피보나치 수 $F(n)$는, 바로 앞의 두 피보나치 수 $F(n-1)$, $F(n-2)$로 나눌수 있다.
- 구조 특징: 전체 문제(n번째) 해답이 두 개의 더 작은 문제(n-1, n-2)의 해답만으로 결정된다.

## (2) 최적해의 값을 재귀적으로 정의한다
다음 단계를 간단하게 말하면 (1)을 기반으로 점화식을 세우는 것이다. 피보나치 문제의 경우 점화식이 알려져 있기 때문에 보다 쉽게 점화식을 쓸 수 있다.

$$F(0) = 0$$
$$F(1) = 1$$
$$ F(n) = F(n-1) + F(n-2)$$

## (3) 최적해의 값을 계산한다
이 단계에서는 알고리즘을 만들어 내야한다. 2번에서 구한 점화식을 이용하되, 동적 프로그래밍 답게 중복 연산을 막기위한 기법을 사용하여야 한다. 구현 방법은 대표적으로 하향식(Top-down) 방법과 상향식(Bottom-up) 방법이 있다.

### 하향식 방법
하향식 방법은 말 그대로 위에서부터 문제를 파악해 내려오는 방식이다. 주로 재귀 함수의 형태로 코드를 작성하나, 각 부분 문제의 결과를 배열이나 해시 테이블에 저장해 놓는데 이것이 메모하기(Memoization)이다. 이 방식으로 피보나치 문제를 해결하는 코드는 아래와 같다.

```python
n = 10  
memo = [None] * (n + 1)       # 메모 해둘 배열

def fib(x):  
    if x == 0: return 0  
    if x == 1: return 1  
    if memo[x] is not None:    # 메모 해 둔 값이 있는지 확인  
        return memo[x]  
    memo[x] = fib(x - 1) + fib(x - 2)  # 메모하기  
    return memo[x]  
  
result = fib(n)
```
처음에 가장 큰 문제(fib(n))를 호출하고, 더 작은 문제(n-1, n-2)로 쪼개어 내려가는 방식이다.
계산 한 값은 memo에 저장해 두고, 필요할 때마다 꺼내쓴다. 이를 위해 부분 문제를 풀기 이전에, 메모해 놓은 값이 있는지 먼저 확인을 하는 단계가 추가 되었다.

### 상향식 방법
상향식 방법은 가장 작은 부분문제부터 해결하면서 점점 더  큰 문제로 확장해 나가는 방식이다. 주로 반복문의 형태로 구현을 한다.

```python
n = 10
dp = [0] * (n + 1)    # 부분 문제의 해를 저장해 놓을 배열
dp[0] = 0
dp[1] = 1
for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2] 
result = dp[n]
print(result) 
```
코드를 보면 가장 작은 문제인 (0, 1)부터 차례로 값을 계산한다. 작은 문제부터 계산하기 때문에, 특정 부분 문제를 풀 때는 그 해에 영향을 미치는 더 작은 부분문제를 이미 풀어 놓은 상태가 된다. 따라서 이미 풀어 놓은 부분 문제를 저장해 두고 그 값을 가져와서 풀면 된다.

두 방식 중에 좀 더 안전한 방식은 상향식 방식이다. 재귀를 사용하는 하향식 방식의 경우 재귀의 깊이 때문에 에러가 발생할 수도 있기 때문이다. 시간 복잡도적 측면에서 점근적인 수행시간은 동일하다. 더 엄밀히 따져 본다면 하위 문제의 결과를 테이블에서 찾기만 하면 되는 상향식 방법이, 재귀 호출을 하고 메모해둔 값이 있는지 확인해야하는 하향식 방법보다 빠를 수 있다.