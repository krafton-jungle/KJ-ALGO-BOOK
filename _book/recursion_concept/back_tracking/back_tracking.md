# 백트래킹 알고리즘 (Backtracking)

이 장에서는 백트래킹 알고리즘의 개념, 동작 원리, 구현 방법, 그리고 실제 적용 예제를 중심으로 학습합니다.

> 이 장에서는 백트래킹 알고리즘의 정의, 동작 원리, 조건 분기 및 되돌리기 구조, 그리고 이를 활용한 문제 해결 전략에 대해 학습합니다.

---

## 목차

| 항목                    | 설명                  |
| --------------------- | ------------------- |
| [핵심 내용 정리](#key)      | 알고리즘 개념, 키워드 정리     |
| [문제 접근 방식](#approach) | 알고리즘을 이해하는 데 필요한 개념 |
| [알고리즘 실행 과정](#excute) | 알고리즘을 시각화 자료와 함께 설명 |
| [알고리즘 구현 코드](#python) | 파이썬으로 구현한 알고리즘 예시   |
| [참고](#refer)          | 자료 출처 및 추가 참고 자료    |

---

## 핵심 키워드 정리 {#key}

* **정의**: 해의 후보를 점진적으로 만들어가다가 조건에 맞지 않으면 되돌아가서(backtrack) 다시 시도하는 완전 탐색 기반 알고리즘
* **주요 특징**:

  * 트리 구조 탐색
  * 상태 공간에서 조건 불충분시 조기 가지치기(pruning)
* **자료구조**: 배열, 재귀 호출 스택, 상태 추적용 보조 배열 등
* **시간복잡도**: 최악의 경우 `O(b^d)` (`b`: 분기 수, `d`: 탐색 깊이)
* **공간복잡도**: `O(d)` (재귀 호출 스택 깊이)
* **동작 방식 요약**:

  * 입력: 가능한 선택지들, 제약 조건
  * 처리: 조건을 만족하는 경우만 다음 단계로 진행
  * 출력: 조건을 모두 만족하는 해를 수집 또는 즉시 반환

---

## 문제 접근 방식 {#approach}

* **백트래킹은 탐색을 전개하고 필요시 후퇴하는 전략**입니다.
* 일반적인 문제는 다음과 같이 정의할 수 있습니다:

  * 상태: 현재까지의 선택지 시퀀스 (ex. `x1, x2, ..., xi`)
  * 목표: 전체 조건 `P_n(x1, ..., xn)`을 만족하는 시퀀스 찾기
  * 조건: 중간 조건 `P_i(x1, ..., xi)`가 불만족될 경우 더 이상 진행하지 않음  

* **알고리즘 구현 시 고려할 점**:

  * 해 공간은 트리로 구성되며, 가지치기(pruning)로 가지 수를 줄이는 것이 핵심
  * 중복 방문 방지 및 상태 추적을 위한 자료구조 설계가 중요

---

## 알고리즘 실행 과정 {#excute}

* 실행 구조 (재귀적 호출 형태):

```
1. 현재 상태가 해인지 검사
2. 아니라면, 가능한 다음 선택지를 반복:
    a. 조건을 만족하면
        - 해당 선택지를 선택하고 다음 단계로 진행 (재귀 호출)
    b. 조건을 만족하지 않으면
        - 백트랙 (다음 선택지로 이동)
```

* 시각 자료 예시 (예: 상태 공간 트리의 일부)

```
         ( )          ← 루트(시작 상태, 아직 아무것도 선택하지 않음)
        / | \
      1   2   3       ← 첫 번째 선택지 (레벨 1에서 1, 2, 3 중 선택)
     / \      |
    4   5     6       ← 다음 단계(레벨 2)에서 가능한 후속 선택지
```

* 결과 출력 예시
```
가능한 해: [1, 4], [2, 5], [3, 6]
```
* 루트부터 리프까지 내려가는 각각의 유효한 경로가 하나의 해(solution) 을 구성함

* 예를 들어, 경로 ( ) → 1 → 4 는 해 [1, 4]를 의미

* 해당 예시는 조건을 만족하는 세 가지 해를 찾았음을 나타냄

---

## 구현 예시 (Python) {#python}

```python
# 백트래킹 템플릿: 조건을 만족하는 해를 모두 탐색

def backtrack(path, options, results):
    if is_solution(path):
        results.append(path[:])  # 해를 저장
        return
    for option in options:
        if is_valid(path, option):  # 조건 검사
            path.append(option)
            backtrack(path, options, results)  # 다음 단계로 진입
            path.pop()  # 백트랙

# 예시 사용
def example():
    options = [1, 2, 3]
    results = []
    backtrack([], options, results)
    return results
```

> 이 코드는 조건 분기 및 되돌리기를 포함한 전형적인 백트래킹 구조를 설명합니다.
> `is_solution`, `is_valid` 함수는 문제에 따라 정의합니다.

---

## 참고 {#refer}

* **참고한 자료**

  * 『The Art of Computer Programming, Volume 4, Fascicle 5』, Donald E. Knuth (7.2.2절)
  * [위키백과 - 백트래킹](https://ko.wikipedia.org/wiki/백트래킹)
  * GeeksforGeeks - [Backtracking](https://www.geeksforgeeks.org/backtracking-introduction/)


* **추가로 참고하면 좋은 자료**

  * [Visualgo - Recursion Tree](https://visualgo.net/en/recursion)
  * LeetCode / 백준에서 "백트래킹" 태그 문제 풀이
