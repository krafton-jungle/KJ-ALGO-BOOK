# ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth-First Search, BFS)

## ğŸ“š ëª©ì°¨

1. [1. ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth-First Search, BFS)](#1-ë„ˆë¹„-ìš°ì„ -íƒìƒ‰breadth-first-search-bfs)
2. [2. BFSëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€](#2-bfsëŠ”-ì–´ë–»ê²Œ-ë™ì‘í•˜ëŠ”ê°€)
3. [3. ì˜ˆì‹œ: ë¬´ë°©í–¥ ê·¸ë˜í”„ íƒìƒ‰](#3-ì˜ˆì‹œ-ë¬´ë°©í–¥-ê·¸ë˜í”„-íƒìƒ‰)
4. [4. BFSê°€ ì™œ ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰ì— ì¢‹ì€ê°€](#4-bfsê°€-ì™œ-ìµœë‹¨-ê±°ë¦¬-íƒìƒ‰ì—-ì¢‹ì€ê°€)
5. [5. ìµœë‹¨ ê²½ë¡œë¥¼ ì¶œë ¥í•˜ë ¤ë©´?](#5-ìµœë‹¨-ê²½ë¡œë¥¼-ì¶œë ¥í•˜ë ¤ë©´)
6. [6. BFSê°€ ë§Œë“  ë„ˆë¹„ ìš°ì„  íŠ¸ë¦¬](#6-bfsê°€-ë§Œë“ -ë„ˆë¹„-ìš°ì„ -íŠ¸ë¦¬)
7. [7. BFSëŠ” ì–´ë””ì— ì“°ì´ëŠ”ê°€](#7-bfsëŠ”-ì–´ë””ì—-ì“°ì´ëŠ”ê°€)
   - [7-1. ë¯¸ë¡œ íƒìƒ‰](#7-1-ë¯¸ë¡œ-íƒìƒ‰)
   - [7-2. ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°](#7-2-ìµœë‹¨-ê±°ë¦¬-ê³„ì‚°)
8. [8. ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜(Bellman-Ford Algorithm)](#8-ë²¨ë§Œ-í¬ë“œ-ì•Œê³ ë¦¬ì¦˜bellman-ford-algorithm)
   - [8-1. ì–´ë–¤ ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆëŠ”ê°€](#8-1-ì–´ë–¤-ë¬¸ì œë¥¼-í’€-ìˆ˜-ìˆëŠ”ê°€)
   - [8-2. ë™ì‘ ì›ë¦¬](#8-2-ë™ì‘-ì›ë¦¬)
   - [8-3. êµ¬í˜„ ì½”ë“œ](#8-3-êµ¬í˜„-ì½”ë“œ)
   - [8-4. ì˜ˆì‹œ](#8-4-ì˜ˆì‹œ)
9. [9. ì •ë¦¬](#9-ì •ë¦¬)
10. [10. ì°¸ê³ ](#10-ì°¸ê³ )

---

## 1. ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth-First Search, BFS)

ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)ì€ ê·¸ë˜í”„ë‚˜ íŠ¸ë¦¬ì—ì„œ **ê°€ì¥ ê°€ê¹Œìš´ ê³³ë¶€í„° ì°¨ë¡€ë¡œ íƒìƒ‰í•˜ëŠ” ë°©ë²•**ì´ë‹¤.  
ì‹œì‘ ë…¸ë“œì—ì„œë¶€í„° ì¸ì ‘í•œ ë…¸ë“œë¥¼ ë¨¼ì € ëª¨ë‘ ë°©ë¬¸í•˜ê³ , ê·¸ ë‹¤ìŒìœ¼ë¡œ ë¨¼ ë…¸ë“œë¥¼ ë°©ë¬¸í•œë‹¤.  
ì´ ë°©ì‹ì€ **ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°**, **ë ˆë²¨ ìˆœíšŒ** ë“±ì— ì‚¬ìš©ëœë‹¤.

## 2. BFSëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ê°€

BFSëŠ” **í(Queue)** ë¼ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•œë‹¤.  
ë¨¼ì € ì‹œì‘ ë…¸ë“œë¥¼ íì— ë„£ê³ , íì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´ë©´ì„œ ê·¸ ë…¸ë“œì™€ ì—°ê²°ëœ ì´ì›ƒ ë…¸ë“œë¥¼ ì°¨ë¡€ë¡œ ë°©ë¬¸í•´ íì— ë„£ëŠ”ë‹¤.  
ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì²´í¬í•´ ì¤‘ë³µ ë°©ë¬¸ì„ ë§‰ëŠ”ë‹¤.

```python
from collections import deque

def bfs(graph, start):
    visited = [False] * len(graph)  # ë°©ë¬¸ ì—¬ë¶€ ë¦¬ìŠ¤íŠ¸
    queue = deque()

    visited[start] = True  # ì‹œì‘ ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
    queue.append(start)

    while queue:
        node = queue.popleft()
        print(node, end=' ')

        for neighbor in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)
```

## 3. ì˜ˆì‹œ: ë¬´ë°©í–¥ ê·¸ë˜í”„ íƒìƒ‰

```python
graph = [
    [],         # 0ë²ˆ ë…¸ë“œëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
    [2, 3, 4],  # 1ë²ˆ ë…¸ë“œëŠ” 2, 3, 4ì™€ ì—°ê²°ë¨
    [1, 4],     # 2ë²ˆ ë…¸ë“œëŠ” 1, 4ì™€ ì—°ê²°ë¨
    [1, 4],     # 3ë²ˆ ë…¸ë“œëŠ” 1, 4ì™€ ì—°ê²°ë¨
    [1, 2, 3],  # 4ë²ˆ ë…¸ë“œëŠ” 1, 2, 3ê³¼ ì—°ê²°ë¨
]

bfs(graph, 1)  # ì¶œë ¥: 1 2 3 4
```

## 4. BFSê°€ ì™œ ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰ì— ì¢‹ì€ê°€

### 4-1. ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ë³´ë‹¤ ì‘ê²Œ ë‚˜ì˜¬ ì¼ì€ ì—†ë‹¤

ëª¨ë“  ì •ì  `v`ì— ëŒ€í•´:

```
ê³„ì‚°ëœ ê±°ë¦¬ v.d >= ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ Î´(s, v)
```

- ì—¬ê¸°ì„œ v.dëŠ” BFSê°€ ê³„ì‚°í•œ ì‹œì‘ì  sì—ì„œ ì •ì  vê¹Œì§€ì˜ ê±°ë¦¬(íƒìƒ‰ ê³¼ì •ì—ì„œ ê¸°ë¡ëœ ê±°ë¦¬)ì´ê³ ,
- ğ›¿(ğ‘ ,ğ‘£)-Î´(s,v)ëŠ” ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ” sì—ì„œ vê¹Œì§€ì˜ ì§„ì§œ ìµœë‹¨ ê±°ë¦¬ì´ë‹¤.

ì¦‰, ê±°ë¦¬ê°€ ì¤„ì–´ë“œëŠ” ê²½ìš°ëŠ” ì—†ê³ , ì •ë‹µì´ê±°ë‚˜ ë” í° ê°’ì´ë‹¤.

### 4-2. íì— ë“¤ì–´ê°€ëŠ” ìˆœì„œëŠ” ê±°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆë‹¤

- íì— ë“¤ì–´ìˆëŠ” ì •ì ë“¤ì„ ì‚´í´ë³´ë©´, ì•ìª½ ì •ì ì´ í•­ìƒ ë” ê°€ê¹Œìš´ ë…¸ë“œì´ë‹¤.
- ê·¸ë˜ì„œ ë‹¤ìŒì— ë°©ë¬¸í•  ë…¸ë“œëŠ” ì§€ê¸ˆê¹Œì§€ ë³¸ ê²ƒë³´ë‹¤ ë©€ë¦¬ ìˆëŠ” ë…¸ë“œì´ë‹¤.

ì¦‰, BFSëŠ” ì¶œë°œì ìœ¼ë¡œë¶€í„° ëª¨ë“  ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì •í™•íˆ ê³„ì‚°í•œë‹¤.

## 5. ìµœë‹¨ ê²½ë¡œë¥¼ ì¶œë ¥í•˜ë ¤ë©´?

ì•„ë˜ í•¨ìˆ˜ëŠ” `predecessor` ë°°ì—´ì„ ì‚¬ìš©í•´ ì‹œì‘ì ë¶€í„° ë„ì°©ì ê¹Œì§€ ê²½ë¡œë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì¶œë ¥í•œë‹¤.

```python
def print_path(predecessor, start, v):
    if v == start:
        print(start, end=' ')
    elif predecessor[v] is None:
        print("ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
    else:
        print_path(predecessor, start, predecessor[v])
        print(v, end=' ')
```

## 6. BFSê°€ ë§Œë“  ë„ˆë¹„ ìš°ì„  íŠ¸ë¦¬

BFSëŠ” ê° ë…¸ë“œê°€ ì–´ë–¤ ë…¸ë“œë¥¼ í†µí•´ ë°©ë¬¸ëëŠ”ì§€ ê¸°ë¡í•œë‹¤.  
ì´ê±¸ ê¸°ë°˜ìœ¼ë¡œ **ë„ˆë¹„ ìš°ì„  íŠ¸ë¦¬**ê°€ ë§Œë“¤ì–´ì§€ëŠ”ë°,  
ì´ëŠ” ì‹œì‘ì ì—ì„œ ëª¨ë“  ë„ë‹¬ ê°€ëŠ¥í•œ ë…¸ë“œë¥¼ **ìµœë‹¨ ê²½ë¡œë¡œ ì—°ê²°í•œ íŠ¸ë¦¬**ì´ë‹¤.

## 7. BFSëŠ” ì–´ë””ì— ì“°ì´ëŠ”ê°€

### 7-1. ë¯¸ë¡œ íƒìƒ‰

2ì°¨ì› ë°°ì—´ë¡œ ëœ ë¯¸ë¡œì—ì„œ ì¶œë°œì ë¶€í„° ë„ì°©ì ê¹Œì§€ ê°€ì¥ ì§§ì€ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤.  
BFSëŠ” í•œ ì¹¸ì”© ì‚¬ë°©ìœ¼ë¡œ í¼ì ¸ ë‚˜ê°€ê¸° ë•Œë¬¸ì— ìµœë‹¨ ê±°ë¦¬ë¥¼ ë³´ì¥í•œë‹¤.

### 7-2. ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°

ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 1ì´ë¼ë©´, ì•„ë˜ì²˜ëŸ¼ ê°„ë‹¨í•˜ê²Œ ìµœë‹¨ ê±°ë¦¬ë„ êµ¬í•  ìˆ˜ ìˆë‹¤.

```python
def shortest_path(graph, start):
    from collections import deque
    distance = [-1] * len(graph)  # -1ì€ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•ŠìŒ
    queue = deque()

    distance[start] = 0
    queue.append(start)

    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if distance[neighbor] == -1:
                distance[neighbor] = distance[node] + 1
                queue.append(neighbor)

    return distance
```

## 8. ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜(Bellman-Ford Algorithm)

BFSëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ëª¨ë‘ ê°™ì„ ë•Œ ì‚¬ìš©í•˜ê¸° ì¢‹ë‹¤.  
í•˜ì§€ë§Œ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ìŒìˆ˜ì¼ ê²½ìš°ì—” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.  
ì™œëƒí•˜ë©´ ì–´ë–¤ ë…¸ë“œì—ì„œ ìŒìˆ˜ ê°„ì„ ì„ ì§€ë‚˜ë©´ ì‹¤ì œ ìµœë‹¨ ê±°ë¦¬ê°€ ì¤„ì–´ë“œëŠ”ë°, BFS ëŠ” íì— ë„£ì€ìˆœì„œëŒ€ë¡œ ë…¸ë“œë¥¼ ë°©ë¬¸í•´ì„œ ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤.
ì´ ê²½ìš°ì—ëŠ” **ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜**ì„ ì‚¬ìš©í•œë‹¤.

### 8-1. ì–´ë–¤ ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆëŠ”ê°€

- ê·¸ë˜í”„ì— **ìŒìˆ˜ ê°€ì¤‘ì¹˜**ê°€ ìˆì–´ë„ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤.
- ë˜í•œ **ìŒìˆ˜ ì‚¬ì´í´**ì´ ì¡´ì¬í•˜ëŠ”ì§€ë„ íŒë‹¨í•  ìˆ˜ ìˆë‹¤.

### 8-2. ë™ì‘ ì›ë¦¬

- ëª¨ë“  ê°„ì„ ì„ **V-1ë²ˆ** ë°˜ë³µí•´ì„œ ì ê²€í•˜ë©°, ë” ì§§ì€ ê²½ë¡œê°€ ìˆìœ¼ë©´ ê°±ì‹ í•œë‹¤.
- ë§ˆì§€ë§‰ì— í•œ ë²ˆ ë” ì ê²€í•´ì„œ ê°±ì‹ ë˜ëŠ” ê°„ì„ ì´ ìˆë‹¤ë©´ **ìŒìˆ˜ ì‚¬ì´í´ì´ ì¡´ì¬**í•œë‹¤.

### 8-3. êµ¬í˜„ ì½”ë“œ

```python
def bellman_ford(edges, vertex_count, start):
    INF = float('inf')
    distance = [INF] * vertex_count
    distance[start] = 0

    for _ in range(vertex_count - 1):
        for u, v, weight in edges:
            if distance[u] != INF and distance[v] > distance[u] + weight:
                distance[v] = distance[u] + weight

    # ìŒìˆ˜ ì‚¬ì´í´ í™•ì¸
    for u, v, weight in edges:
        if distance[u] != INF and distance[v] > distance[u] + weight:
            return None  # ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬

    return distance
```

### 8-4. ì˜ˆì‹œ

```python
edges = [
    (0, 1, 4),
    (0, 2, 5),
    (1, 2, -3),
    (2, 3, 4),
]

distance = bellman_ford(edges, 4, 0)

if distance is None:
    print("ìŒìˆ˜ ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤.")
else:
    print(distance)
# ì¶œë ¥: [0, 4, 1, 5]
```

## 9. ì •ë¦¬

| ì•Œê³ ë¦¬ì¦˜           | íŠ¹ì§•                                      | ì‹œê°„ ë³µì¡ë„  | ìŒìˆ˜ ê°„ì„  í—ˆìš© |
| ------------------ | ----------------------------------------- | ------------ | -------------- |
| BFS                | ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰, ìµœë‹¨ ê±°ë¦¬ ê³„ì‚° ê°€ëŠ¥ | \$O(V + E)\$ | ì•ˆ ë¨          |
| ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ | ìŒìˆ˜ ê°„ì„  í—ˆìš©, ìŒìˆ˜ ì‚¬ì´í´ íƒì§€ ê°€ëŠ¥     | \$O(VE)\$    | ê°€ëŠ¥           |

## 10. ì°¸ê³ 

ê°œì¸ë¸”ë¡œê·¸ : ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ (https://headf1rst.github.io/algorithm/bellmanford/)
