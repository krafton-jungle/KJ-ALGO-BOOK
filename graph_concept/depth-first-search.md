# 깊이 우선 탐색(Depth-First Search, DFS)

## 📚 목차

1. [깊이 우선 탐색(Depth-First Search, DFS)](#깊이-우선-탐색depth-first-search-dfs)
2. [DFS로 작성한 그래프 순회 예시 (재귀 방식)](#dfs로-작성한-그래프-순회-예시-재귀-방식)
3. [예시: 그래프와 실행](#예시-그래프와-실행)
4. [DFS가 왜 백트래킹/경로탐색/사이클 탐지에 적합한가](#dfs가-왜-백트래킹경로탐색사이클-탐지에-적합한가)
5. [DFS 트리의 특징](#dfs-트리의-특징)
6. [BFS가 만든 너비 우선 트리](#bfs가-만든-너비-우선-트리)
7. [DFS는 어디에 쓰이는가](#dfs는-어디에-쓰이는가)
   - [경로 탐색](#1-경로-탐색)
   - [백트래킹 (예: N-Queen)](#2-백트래킹-예-N-Queen)
8. [위상 정렬(Topological Sort)](#위상-정렬topological-sort)
   - [어떤 문제를 풀 수 있는가](#어떤-문제를-풀-수-있는가)
   - [동작 원리 (DFS 기반 위상 정렬)](#동작-원리dfs-기반-위상-정렬)
   - [구현 코드](#구현-코드)
9. [주의할 점](#주의할-점)

---

깊이 우선 탐색(DFS)은 그래프나 트리에서 **가장 깊은 노드까지 먼저 탐색**한 뒤, 더 이상 갈 곳이 없으면 다시 돌아와서 다른 경로를 탐색하는 방식이다.
스택 자료구조를 사용하거나 재귀 호출을 통해 구현할 수 있다.
이 방식은 **경로 탐색**, **사이클 탐지**, **백트래킹** 문제 등에 유용하다.

## DFS로 작성한 그래프 순회 예시 (재귀 방식)

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    visited.add(start)
    print(start, end=' ')  # 또는 처리하고 싶은 작업 수행

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

## 예시: 그래프와 실행

```python
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

dfs(graph, 'A') # 출력: A B D E F C
```

## DFS가 왜 백트래킹/경로탐색/사이클 탐지에 적합한가

### 1. 경로를 **깊이 따라가며** 탐색하므로 완전 탐색에 유리하다.

DFS는 현재 노드에서 갈 수 있는 모든 경로를 깊이 따라가며 조사한다.

- 경로를 하나 정하고 **끝까지 가본 뒤**, 목적에 따라 **되돌아온다.**
- 이를 통해 모든 가능한 경로를 확인할 수 있고, 원하는 조건의 경로를 찾으면 그만둘 수도 있다.

### 2. 탐색 중인 경로를 쉽게 추적할 수 있다.

DFS는 재귀 호출 또는 스택을 통해 호출 스택 상에서 현재 경로의 상태를 그대로 유지한다.

즉, 백트래킹 조건이 충족되지 않을 경우 쉽게 **이전 상태**로 돌아가서 다른 선택지를 탐색할 수 있다.

## DFS 트리의 특징

### 1. 탐색 경로의 계층 구조

DFS 트리는 정점들이 방문된 순서와 재귀 호출의 흐름을 그대로 반영한다. DFS 수행 중 부모 정점에서 자식 정점으로의 연결은 호출이 실제로 일어난 순서이며, 이 구조는 탐색의 실행 경로를 계층적으로 보여주는 트리 형태가 된다.

### 2. 포리스트(forest) 형성

그래프가 하나의 연결 요소로 이루어져 있지 않은 경우, DFS는 각 연결 요소에 대해 별도의 트리를 만들어낸다. 이로 인해 전체 탐색 결과는 여러 개의 트리로 구성된 포리스트가 되며, 그래프의 연결 구조를 자연스럽게 분해해 보여준다.

### 3. 정점 간 포함 관계를 나타냄

DFS는 각 정점의 발견 시간(d)과 종료 시간(f)을 기록함으로써 정점 간의 포함 관계를 명확히 알 수 있게 한다. 예를 들어, 어떤 정점 u의 d와 f 사이에 정점 v의 d와 f가 완전히 포함되어 있다면, v는 u의 자손이라는 것을 의미한다. 이런 정보는 DFS로는 알 수 없고 DFS 특유의 시간 기록 방식에서만 얻을 수 있다.

### 4. 간선을 분류할 수 있는 기반

DFS가 만든 트리는 단순히 정점을 연결하는 구조에 그치지 않고, 그래프의 모든 간선을 구조적으로 분류할 수 있는 기준이 된다. 트리 간선은 탐색 중 실제로 만들어진 간선이고, 역방향 간선은 현재 정점의 조상으로 향하는 간선으로, 사이클 존재 여부를 판단하는 데 핵심적이다. 순방향 간선은 자손 방향이지만 트리에 포함되지 않은 간선이며, 교차 간선은 서로 다른 서브트리 사이를 연결하는 간선이다. 이 네 가지 간선 유형은 위상 정렬, 강한 연결 요소 분해(SCC) 등 고급 그래프 알고리즘의 이론적 기반이 된다.

---

## DFS는 어디에 쓰이는가

### 1. 경로 탐색

DFS는 특정한 목적까지의 경로가 있는지를 빠르게 확인할 수 있으며, 모든 경로를 확인하거나 조건에 따라 중단할 수 있는 유연성을 가진다.

### 2. 백트래킹 (예: N-Queen)

- DFS를 한 행씩 내려가며 현재 행에 퀸을 둘 수 있는 열을 탐색한다.
- 유효한 위치에 퀸을 놓으면 다음 행으로 재귀 호출한다.
- 다음 단계에서 조건을 만족하지 않으면 이전 상태로 되돌아와(백트래킹) 다른 선택지를 시도한다.
- 유효한 배치가 끝까지 도달하면 정답 카운트를 올린다.

DFS의 재귀 구조는 백트래킹을 자연스럽게 구현할 수 있으며, **조건 검사 + 복원(undo)** 조합이 핵심이다.

---

## 위상 정렬(Topological Sort)

**위상 정렬(topological sort)**은 방향 그래프(DAG, Directed Acyclic Graph)에서
모든 정점을 모든 간선의 방향을 거스르지 않고 나열하는 순서를 말한다.

즉, 간선 `u → v`가 있다면, 위상 정렬된 순서에서 `u`가 `v`보다 항상 먼저 나와야 한다.

### 어떤 문제를 풀 수 있는가

- 과목 이수 순서 결정 (선수 과목이 있을 때)
- 작업 스케줄링 (A 작업 후에 B 작업을 해야 할 때)
- 소프트웨어 빌드 순서
- 프로젝트 종속성 분석

### 동작 원리 (DFS 기반 위상 정렬)

1. 방문하지 않은 정점을 선택하여 DFS를 수행한다.
2. DFS는 인접한 정점들을 모두 탐색한 후 현재 정점을 스택에 `push`한다.
3. DFS가 끝난 후, 스택에 있는 정점들을 역순으로 꺼내면 위상 정렬 결과가 된다.

> 이 방식은 DFS의 **후위 순회(Post-order)**에 기반하고 있다.

## 구현 코드

```python
def topological_sort(graph, n):
    visited = [False] * n
    stack = []

    def dfs(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs(v)
        stack.append(u)

    for i in range(n):
        if not visited[i]:
            dfs(i)

    # 위상 정렬 결과는 스택을 뒤집은 것
    return stack[::-1]

# 예시 그래프: 0 → 1 → 2, 0 → 3
graph = {
    0: [1, 3],
    1: [2],
    2: [],
    3: []
}

result = topological_sort(graph, 4)
print("위상 정렬 결과:", result) # 위상 정렬 결과: [0, 3, 1, 2]
```

## 주의할 점

- 사이클이 있는 경우 위상 정렬은 불가능하다.
- 이 알고리즘은 <strong>DAG(유향 비순환 그래프)</strong>에만 적용된다.
- 사이클 탐지를 위해 `visited` 상태를 3단계(WHITE/GRAY/BLACK)로 확장하면 된다.
