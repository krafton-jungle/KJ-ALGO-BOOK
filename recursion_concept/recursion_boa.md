### 재귀란 무엇인가?

재귀(recursion)란 어떤 개념이나 과정을 자기 자신을 사용해서 정의하거나 해결하는 방법이다. 프로그래밍에서는 함수가 자기 자신을 호출하는 방식으로 나타나며, 이런 함수를 재귀 함수(recursive function)라고 부른다.

재귀는 마치 거울 속에 또 다른 거울이 있어 끝없이 이어지는 반사처럼, 어떤 구조가 자신과 닮은 구조를 반복적으로 포함하고 있는 개념이다.

### 왜 재귀를 배우는가?

재귀는 복잡한 문제를 간결하고 직관적인 코드로 표현할 수 있는 도구이다. 특히 반복 구조가 중첩되거나, 스스로를 닮은 형태로 문제를 쪼갤 수 있을 때 유용하다.

1. 코드를 더 짧고 명확하게 쓸 수 있다.
2. 문제를 단계적으로 나눠서 사고하는 연습을 할 수 있다.
3. 어떤 문제는 재귀적으로 접근할 때 효율적이게 해결 가능한 경우도 있다.

### 재귀는 어떻게 작동하는가?

재귀 함수는 복잡한 문제를 더 단순한 문제로 나누고, 그 단순해진 문제를 자기 자신에게 다시 맡기는 방식으로 작동한다. 이렇게 함으로써 반복적인 구조를 코드 안에서 간결하게 표현할 수 있다. 재귀 함수의 구조는 두 가지 핵심 요소로 구성된다. 바로 기저 조건(Base Case) 과 재귀 조건(Recursive Case) 이다. 이 두 가지가 모두 있어야 재귀가 제대로 작동할 수 있다 그 이유를 알아보자.

### 왜 Base Case가 필요한가?

Base Case는 재귀 호출을 종료시키는 '기저 조건'으로, 문제 해결의 가장 단순한 형태를 의미한다. base case가 없으면 함수는 계속해서 자기 자신을 부르고 또 부르게 되는 무한 루프에 빠지게 된다. 결국 컴퓨터가 감당할 수 있는 함수 호출 횟수를 넘기면 스택 오버플로(Stack Overflow) 라는 오류가 발생한다.

쉽게 말하면, 기저 조건은 재귀 함수가 종료되는 조건이다. 조건이 만족되면 함수는 더 이상 자기 자신을 호출하지 않고 값을 반환한다. base case는 상황에 따라 하나 이상일 수도 있다.

### 왜 recursive case가 필요한가?

Recursive Case는 문제를 더 작은 단위로 분해하고, 그 작은 문제를 자기 자신에게 다시 맡기는 재귀 호출 단계이다. 기저 조건에 아직 도달하지 않았다면, 함수는 문제를 더 작은 형태로 바꾸고, 그 작아진 문제를 다시 자기 자신에게 맡기는 단계로 들어간다. 이게 바로 재귀 호출 단계, 혹은 재귀 조건이다. 이 과정을 반복하며 점점 기저 조건 쪽으로 가까워진다. recursive case가 잘못 설계되면, base case에 도달하지 못하고 무한 재귀 호출이 일어날 수 있기에 주의해야 한다.

## **재귀 호출은 어떻게 진행되는가?**

스택과 재귀 호출 1차 이후 적을 것.

스택 시각화 자료

## 재귀의 종류

재귀 호출이 어떻게 이루어지는지에 따라 네 가지 주요 재귀 종류를 분류한다. 각 재귀 종류는 프로그램의 흐름과 구조에 따라 적절히 활용된다.

### 1. 유한 재귀 (Finite Recursion)

재귀 호출이 종료 조건(base case)에 도달하면 더 이상 호출하지 않고 종료되는 재귀이다. 일반적으로 문제를 더 작은 문제로 나누면서 종료 조건을 명확히 한다.

```c
// 팩토리얼 계산 - 유한 재귀 예제
#include <stdio.h>

int factorial(int n) {
    if (n == 0) return 1;  // 종료 조건
    return n * factorial(n - 1);
}

int main() {
    int num = 5;
    printf("factorial(%d) = %d\\n", num, factorial(num));
    return 0;
}
```

### 2. 무한 재귀 (Infinite Recursion)

종료 조건이 없거나 도달하지 않아 함수가 무한히 자기 자신을 호출하는 경우이다. 스택 오버플로우를 일으키므로 일반적으로 피해야 한다.

```c
c
복사편집
// 무한 재귀 예제 - 주의! 실행하지 말 것
#include <stdio.h>

void infinite_recursion() {
    printf("무한 재귀 호출\n");
    infinite_recursion();  // 종료 조건 없음 -> 무한 호출
}

int main() {
    infinite_recursion();
    return 0;
}

```

### 3. 직접 재귀 (Direct Recursion)

함수 자신이 직접 자기 자신을 호출하는 형태이다.

```c
c
복사편집
// 직접 재귀 예제 - 피보나치 수열
#include <stdio.h>

int fibonacci(int n) {
    if (n <= 1) return n;  // 종료 조건
    return fibonacci(n - 1) + fibonacci(n - 2);  // 직접 재귀 호출
}

int main() {
    int num = 7;
    printf("fibonacci(%d) = %d\n", num, fibonacci(num));
    return 0;
}

```

### 4. 간접 재귀 (Indirect Recursion)

두 개 이상의 함수가 서로를 호출하며 순환하는 형태이다.

```c
c
복사편집
// 간접 재귀 예제
#include <stdio.h>

void functionA(int n);
void functionB(int n);

void functionA(int n) {
    if (n > 0) {
        printf("functionA: %d\n", n);
        functionB(n - 1);
    }
}

void functionB(int n) {
    if (n > 0) {
        printf("functionB: %d\n", n);
        functionA(n / 2);
    }
}

int main() {
    functionA(10);
    return 0;
}

```

고급 재귀 

- 꼬리 재귀
- 꼬리 재귀와 일반 재귀 차이점
- 꼬리 재귀 사용 목적 등
- 같은 문제를 일반 재귀와 꼬리 재귀로 비교하는 예시.
- 파이썬에서는 꼬리 재귀를 왜 신경 쓰지 않아도 될까? (Python은 꼬리 재귀 최적화를 지원하지 않음) -영상

## 

재귀 함수에 한계와 위험

- 스택 오버 플로우
- 재귀 깊이 제한 (특정 언어)
- 동일 기능 반복문 작성 가능
- 메모제이션

## 재귀 vs 반복문

재귀와 반복문은 프로그래밍에서 반복 작업을 수행하는 두 가지 기본 기법이다. 각각의 특징과 적합한 사용 사례가 다르며, 상황에 따라 장단점이 있다.

### 재귀 vs 반복문 차이점

| 구분 | 재귀 (Recursion) | 반복문 (Iteration) |
| --- | --- | --- |
| 동작 원리 | 함수가 자기 자신을 호출하며 문제를 분할해서 해결 | 조건에 따라 코드 블록을 반복 실행 |
| 코드 구조 | 간결하고 문제의 수학적 구조 표현에 적합 | 직관적이고 명확한 반복 제어 |
| 메모리 사용 | 호출 스택을 사용해 메모리 오버헤드 존재 | 메모리 효율적, 별도의 스택 사용 없음 |
| 성능 | 호출 및 반환 비용으로 다소 느릴 수 있음 | 일반적으로 더 빠르고 효율적임 |
| 안정성 | 깊은 재귀 호출 시 스택 오버플로우 위험 있음 | 스택 오버플로우 위험 없음 |
| 디버깅 | 재귀 깊이가 깊으면 디버깅 어려움 | 상대적으로 디버깅 용이 |
| 적용 예시 | 트리 탐색, 분할 정복, 그래프 DFS 등 | 선형 탐색, 배열 순회, 단순 반복 계산 등 |

---

### 재귀가 더 나은 대표적 사례

- **트리 탐색(Tree Traversal)**: 깊이 우선 탐색(DFS) 등 트리 구조를 자연스럽게 처리
- **분할 정복(Divide and Conquer)**: 병합 정렬, 퀵 정렬 등 문제를 분할해 처리
- **그래프 탐색**: DFS 구현 시 간결한 코드 작성 가능
- **수학적 문제 해결**: 피보나치 수열, 하노이 탑, 팩토리얼 계산 등

---

### 반복문이 더 나은 대표적 사례

- **선형 탐색(Linear Search)**: 단순 반복 계산과 순차 탐색
- **배열 순회 및 집계 작업**: 합계, 최대값, 최소값 계산
- **명확한 반복 횟수 지정 작업**: 카운팅, 인덱스 기반 접근
- **성능과 메모리 효율이 중요한 경우**

---

### 현업에서 반복문을 더 선호하는 이유

- 재귀는 호출 스택 사용으로 메모리 오버헤드가 크고, 깊은 재귀는 스택 오버플로우 위험이 있다.
- 반복문은 실행 속도가 빠르고, 메모리 관리가 용이하다.
- 많은 프로덕션 환경에서 안정성과 성능이 우선시되기 때문에 반복문이 기본 선택지로 자리 잡았다.
- 디버깅과 유지보수가 상대적으로 쉽다.

---

### 스택 오버플로우: 재귀와 반복문 중 무엇이 더 나은가?

https://stackoverflow.com/questions/72209/recursion-or-iteration

재귀와 반복문에 대한 더 자세한 이야기는 링크에서 확인할 수 있다.

재귀 함수 디버깅 팁

- print로 호출 깊이 추적
- base case 조건 점검
- 최대 재귀 깊이 설정
- 재귀요정을 믿을 것