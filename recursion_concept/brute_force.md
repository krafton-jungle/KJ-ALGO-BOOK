# 완전탐색(Brute Force)이란 무엇인가?

완전탐색은 현대 컴퓨터가 등장하기 훨씬 이전, 고전 수학 및 논리학에서 해를 찾는 방법으로 등장했다.

대표적인 예는 다음과 같다:

- 기원전 3세기 유클리드 시대: 모든 수를 나눠보며 최대공약수를 찾는 시도
- 19세기 말 수학자들이 체계적 증명 탐색을 위해 고안한 시도:
    - 모든 수학적 추론의 기계적 증명 가능성을 연구 (Hilbert’s Entscheidungsproblem)

이러한 맥락은 계산 가능성(computability) 이론으로 발전하였으며,

1936년 Alan Turing은 "튜링 기계"를 통해 모든 가능한 상태를 탐색하는 계산 모델을 제안했다.

이것이 완전탐색의 이론적 뿌리이다.

1950~60년대 전자식 컴퓨터가 등장하면서, 완전탐색은 단순하면서도 해결 가능한 문제 수를 늘리는 실질적인 수단으로 채택되었다.

- 예: 체스, 8퀸, TSP(외판원 문제) 등
- Bellman(1957): 완전탐색 기반의 최적화 알고리즘에서 중복 탐색을 줄이는 기법(동적 계획법) 도입
- Cook(1971), Karp(1972): 완전탐색 말고는 해결 방법이 알려지지 않은 문제(NP-완전)를 공식화

## 왜 완전탐색이 만들어졌는가?

> “가능한 해가 적으면, 모두 직접 확인하는 것이 가장 확실하다.”
> 

완전탐색은 다음과 같은 이유로 선택되었다:

- 해가 적거나 제한적인 문제는 완전탐색이 유일한 확실한 방법이다.
- 문제를 정형화하기 어렵거나 규칙성이 없는 경우, 완전탐색은 최후의 수단이다.
- 이론적으로, 완전탐색은 항상 정답을 구할 수 있는 방법이다.
- 특정 문제는 문제 자체보다 알고리즘 설계가 더 어렵다. 이 경우 완전탐색으로 빠르게 시도할 수 있다.

<br>

# 완전탐색의 개념

완전탐색은 가능한 모든 경우의 수를 빠짐없이 탐색하여 정답을 찾는 알고리즘 기법이다.

문제의 조건이 작고 경우의 수가 많지 않을 때, 완전탐색은 가장 직관적이고 확실한 방법이 된다.

문제에서 요구하는 조건을 만족하는 해답이 반드시 존재하며, 그것을 찾기 위해 모든 후보를 생성하고 확인한다.

다르게 표현하면, "답이 될 수 있는 모든 경우를 무식하게 하나씩 전부 시도해본다"는 점에서 Brute Force(무차별 대입)라고 불린다.

이 기법은 정답을 반드시 찾을 수 있다는 장점이 있으나, 경우의 수가 많을 경우 시간 초과가 발생할 수 있다.

따라서 완전탐색을 적용할 때는 입력 범위와 시간복잡도를 정확히 판단하는 것이 중요하다.

### 왜 완전탐색이 중요한가?

1. 탐색의 기본이 되는 사고방식이다.
    
    처음에 완전탐색으로 접근하여 문제를 이해하고, 그 다음에 최적화하는 방식으로 발전시킬 수 있다.
    
2. 백트래킹, DFS, 그리디, DP 등 고급 기법으로 확장 가능하다.
3. 경우의 수가 작거나, 정확성이 중요한 경우에 매우 유효하다.

<br>

# 완전탐색이 필요한 경우

완전탐색은 다음과 같은 상황에서 효과적이다:

- 경우의 수가 작을 때
    - 완전탐색은 가능한 모든 경우를 전부 시도해보는 방식이기 때문에, 경우의 수가 너무 많아지면 실행 시간이 기하급수적으로 증가한다.
        - 예를 들어, 숫자 N개의 순열을 구한다고 하면 경우의 수는 `N!`(팩토리얼)이다.
    - 컴퓨터는 일반적으로 1초에 **1억(10⁸)번 이하의 연산**을 처리할 수 있다. 완전탐색은 모든 경우를 시도하므로, 이 기준을 넘으면 시간 초과가 발생할 수 있다.
        
        
        | N | N! (경우의 수) | 탐색 가능 여부 |
        | --- | --- | --- |
        | 5 | 120 | 매우 빠름 |
        | 7 | 5,040 | 괜찮음 |
        | 9 | 362,880 | 대부분 가능 |
        | 10 | 3,628,800 | 가능하나 경계선 |
        | 11 | 39,916,800 | 위험 |
        | 12 | 479,001,600 | 거의 불가능 |
- 최적해를 구해야 할 때: 예를 들어, 최소값이나 최대값을 정확히 구해야 할 경우
- 조건을 만족하는 모든 경우를 탐색해야 할 때: 모든 가능한 조합이나 순열을 확인하는 문제 등
- 단순한 조건 검증을 해야 할 때: 규칙성이 명확하지 않거나, 예외 처리가 복잡한 경우

### 시간복잡도와 제한 조건 분석법

완전탐색 문제를 해결하기 전에는 입력 범위와 시간 제한을 바탕으로 시간복잡도를 분석해야 한다.

| 입력 크기(N) | 가능한 최대 연산 수 | 가능한 탐색 방법 |
| --- | --- | --- |
| N ≤ 10 | 약 10! (백만 단위) | 순열, 조합 전부 탐색 가능 |
| N ≤ 15~20 | 약 2N2^N (백만~천만 단위) | 부분집합, DFS 등 |
| N ≤ 100 | 약 N2N^2 | 이중 반복문 가능 |
| N ≤ 1,000 | 약 N3N^3 이하 | 제한적 3중 반복 가능 |
| N ≤ 100,000 | 약 Nlog⁡NN \log N | 정렬, 이분 탐색 등 사용해야 함 |
| N ≥ 1,000,000 | 약 O(N)O(N) 또는 그 이하 | 매우 빠른 알고리즘 필요 |

<br>

# 완전탐색을 컴퓨터 시스템에서 활용하는 방식

| 활용 분야 | 구체적 사례 | 완전탐색의 역할 |
| --- | --- | --- |
| **성능 측정** | CPU/GPU 성능 벤치마크 | 병렬성, 분기예측, 파이프라인 효율 측정 |
| **보안** | 패스워드 크래킹, 해시 충돌 | 무작위 대입 방식으로 보안 강도 측정 |
| **컴파일러 최적화 연구** | 루프 전개, 함수 인라이닝 전후 | 단순 반복구조 성능 비교 실험 |
| **알고리즘 이론 검증** | DP, 탐욕법 성능 비교 | 완전탐색을 기준으로 정확성·속도 측정 |
| **프로토타이핑** | 알고리즘 성능 테스트의 기준 | 초기 구현의 정확한 기준점 제공 |

<br>

# 완전탐색 구현 패턴 소개

완전탐색을 구현하는 대표적인 방법은 다음과 같다:

1. 중첩 반복문 사용
    - 가장 단순한 완전탐색 구현 방법이다. 반복문을 여러 번 중첩하여 모든 경우를 수동으로 탐색한다.
    
    ```c
    #include <stdio.h>
    
    int main() {
        // 1부터 3까지 두 수의 모든 조합을 출력
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                printf("(%d, %d)\n", i, j);
            }
        }
        return 0;
    }
    ```
    
2. 재귀 함수 사용
    - 특정 조건에서 종료되는 방식으로, 깊이를 조절하여 순열, 조합, 부분집합을 구현할 수 있다.
    
    ```c
    // 순열
    #include <stdio.h>
    
    int used[4] = {0}; // 1~3 숫자 사용 여부
    int result[4];
    
    void perm(int depth) {
        if (depth == 3) {
            for (int i = 0; i < 3; i++) {
                printf("%d ", result[i]);
            }
            printf("\n");
            return;
        }
    
        for (int i = 1; i <= 3; i++) {
            if (!used[i]) {
                used[i] = 1;
                result[depth] = i;
                perm(depth + 1);
                used[i] = 0;
            }
        }
    }
    
    int main() {
        perm(0);
        return 0;
    }
    ```
    
    ```c
    // 조합
    #include <stdio.h>
    
    int arr[] = {1, 2, 3, 4};
    int result[3];
    int n = 4;
    
    void comb(int start, int depth) {
        if (depth == 3) {
            for (int i = 0; i < 3; i++) {
                printf("%d ", result[i]);
            }
            printf("\n");
            return;
        }
    
        for (int i = start; i < n; i++) {
            result[depth] = arr[i];
            comb(i + 1, depth + 1);
        }
    }
    
    int main() {
        comb(0, 0);
        return 0;
    }
    ```
    
3. itertools 라이브러리 사용 (Python)
    - `permutations`, `combinations`, `product` 등을 통해 간결하게 구현 가능하다.
4. 비트마스킹 활용
    - 부분집합 탐색 등에서 효율적으로 경우의 수를 표현할 수 있다.
    
    ```c
    // 비트마스킹을 이용한 부분집합 탐색
    #include <stdio.h>
    
    int main() {
        int arr[] = {1, 2, 3};
        int n = 3;
    
        for (int i = 0; i < (1 << n); i++) {
            printf("{ ");
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) {
                    printf("%d ", arr[j])
                }
            }
            printf("}\n");
        }
    
        return 0;
    }
    ```
    
5. 백트래킹 기법과 결합
    - 불필요한 탐색을 가지치기 하여 탐색 시간을 줄일 수 있다.
    - 완전탐색의 변형이자 고급 구현 방식이다.
    
    ```c
    // N-Queen 4x4
    
    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    
    int col[15];
    int n = 4;
    int count = 0;
    
    int is_valid(int row) {
        for (int i = 0; i < row; i++) {
            if (col[i] == col[row] || abs(col[row] - col[i]) == row - i) {
                return 0;
            }
        }
        return 1;
    }
    
    void queen(int row) {
        if (row == n) {
            count++;
            return;
        }
    
        for (int i = 0; i < n; i++) {
            col[row] = i;
            if (is_valid(row)) {
                queen(row + 1);
            }
        }
    }
    
    int main() {
        queen(0);
        printf("해결 방법 수: %d\n", count);
        return 0;
    }
    
    ```
    

완전탐색의 확장

- 백트래킹
- DFS/BFS
- 메모이제이션과 DP로 전환되는 흐름

이 부분에서 “처음엔 완전탐색으로 짜고, 이후 가지치기나 최적화로 발전시킨다”는 사고법 강조
