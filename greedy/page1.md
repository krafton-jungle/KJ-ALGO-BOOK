# 그리디 알고리즘 (Greedy Algorithm)

- 그리디 알고리즘은, 매 순간 현재 상황에서 **가장 좋아 보이는 선택**을 반복하는 알고리즘이다.
  - 이러한 선택을 **탐욕적 선택**이라 부른다.
- 그리디 알고리즘을 사용했을 때 문제의 정답(최적해)이 보장되는 경우도 있고, 보장되지 않는 경우도 있다.
- 따라서 **문제에 그리디 알고리즘을 적용할 수 있는지 판단**하는 것이 중요하다.
  - 단순히 최선의 선택을 하는 만큼 시간 복잡도가 낮은 편이지만, 엉뚱한 답을 낼 수도 있다.
- 특히 비슷한 문제 같아 보여도, 약간의 조건 차이 때문에 그리디 알고리즘을 쓸 수 있는 경우와 없는 경우가 나뉠 수 있음에 유의해야 한다.

# 거스름돈 문제

- 거스름돈 문제는, 여러 단위의 동전이 무한히 존재할 때 목표 금액을 만들기 위한 최소 동전 수를 구하는 문제이다.
- 동전 단위의 구성에 따라 그리디 알고리즘의 사용 가능 여부가 달라진다.

## 그리디 알고리즘을 사용할 수 있는 경우

- 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다.
- 위 동전으로 1,260원을 만들 때, **필요한 최소한 동전 수**를 구해 보자.
- 이때 **가장 큰 단위의 동전부터** 있는 대로 사용하면 정답을 구할 수 있다.

| 단위  | 몇 개?  | 남은 돈               |
| ----- | ------- | --------------------- |
| 500원 | 2개     | 1260 - 500 \* 2 = 260 |
| 100원 | 2개     | 260 - 100 \* 2 = 60   |
| 50원  | 1개     | 60 - 50 \* 1 = 10     |
| 10원  | 1개     | 10 - 10 \* 1 = 0      |
| 계    | **6개** |

- **큰 단위가 항상 작은 단위의 배수이므로**, 큰 단위를 먼저 사용하는 것이 무조건 유리하다.
  - 예를 들어, 500원을 놔두고 굳이 100원 5개를 쓸 이유는 없다.
  - 마찬가지로, 100원을 놔두고 굳이 50원 2개를 쓸 이유는 없다.

### 구현

```python
N = 1260
coins = [500, 100, 50, 10]
answer = 0

for c in coins:
    answer += N // c    # 현재 사용한 동전 수를 정답에 추가
    N = N % c           # 동전 다 쓰고 남은 돈

if N <= 0:              # N원을 만드는 데 성공
    print(answer)
else:                   # N원을 만들지 못함
    print("FAIL")

# 결과: 6
```

- 동전의 종류가 `K`개일 때, 위 코드의 시간 복잡도는 `O(K)`이다.
  - `for`문으로 각 동전 종류를 순회하기 때문이다.
- 일일이 `N`원을 만드는 모든 경우의 수를 고려하지 않아도, 문제를 빠르게 풀 수 있음

## 그리디 알고리즘을 사용할 수 없는 경우

- 이번엔 사용 가능한 동전의 단위가 500원, 400원, 100원일 때 800원을 만들어 보자.
- 우선 그리디 알고리즘을 통해, 높은 단위의 동전부터 있는 대로 사용할 수 있다.

| 단위  | 몇 개?  | 남은 돈                |
| ----- | ------- | ---------------------- |
| 500원 | 1개     | 800 - 500 \* 1 = 300원 |
| 400원 | 불가능  | 300원                  |
| 100원 | 3개     | 300 - 100 \* 3 = 0원   |
| 계    | **4개** |

- 하지만, 400원 2개로 800원을 만들 수 있다.
  - 그리디 알고리즘을 사용 시 총 4개의 동전을 사용해야 하는데, 이는 최적해로 볼 수 없다.
- **동전 단위가 배수를 이루지 않으므로**, 그리디 알고리즘은 최적해를 보장하지 않는다.
  - 이럴 땐 동적 계획법(Dynamic Programming)을 사용해, 800원을 만들 수 있는 모든 조합을 분석해야 한다.

# 배낭 문제

- 배낭 문제는, 무게와 금액이 다른 짐들을 배낭에 넣는 문제이다.
- 이때 배낭이 담을 수 있는 최대 무게를 초과하지 않고서, 담은 짐들의 금액을 최대로 하는 방법을 찾아야 한다.
- 본 글에서는 아래와 같은 예제를 사용한다.

| 짐 번호        | 무게 | 금액    |
| -------------- | ---- | ------- |
| A              | 10kg | 1,900원 |
| B              | 7kg  | 1,000원 |
| C              | 6kg  | 1,000원 |
| 배낭 최대 무게 | 15kg |

## 그리디 알고리즘을 사용할 수 있는 경우

- 짐을 **1kg 단위로 쪼갤 수 있는 경우**, 그리디 알고리즘으로 배낭 문제를 해결할 수 있다.

  - 예를 들어, 짐 A가 10kg에 1900원일 때, 5kg만 쪼개 넣을 수 있다.
  - 이때 짐의 금액은 전체 중 5kg에 해당하는 950원이 된다.

- 아래와 같은 절차를 따르면 된다.
  - **1단계** 짐별로 1kg당 금액을 구한다.
  - **2단계** 1kg당 금액이 가장 높은 짐부터 넣는다.
    - 배낭의 남은 무게가 충분한 경우, 짐 전체를 넣는다.
    - 배낭의 남은 무게가 짐의 무게보다 큰 경우, 넣을 수 있는 만큼만 쪼개 넣는다.
  - **3단계** 배낭이 다 찰 때까지 반복한다.
- 이 방식대로 위의 예제에 적용해 보자. 우선 3개의 짐에 대해, 1kg당 금액을 계산한다.

| 번호           | 무게 | 금액    | 1kg당 금액        |
| -------------- | ---- | ------- | ----------------- |
| A              | 10kg | 1,900원 | 1900 \ 10 = 190원 |
| B              | 7kg  | 1,000원 | 1000 \ 7 = 142원  |
| C              | 6kg  | 1,000원 | 1000 \ 6 = 166원  |
| 배낭 최대 무게 | 15kg |

- 1kg당 금액이 높은 **A(190) -> C(약 166) -> B(약 142)** 순으로 짐을 넣는다.
  - 이때 C의 경우 짐 전체를 넣기에는 배낭의 공간이 부족하므로, 6kg 중 5kg만 쪼개서 넣는다.

| 넣을 짐          | 넣은 무게      | 넣은 금액 | 배낭의 남은 무게 |
| ---------------- | -------------- | --------- | ---------------- |
| A (10kg, 1900원) | 10kg           | 1900원    | 15 - 10 = 5kg    |
| C (6kg, 1000원)  | 5kg            | 약 833원  | 5 - 5 = 0kg      |
| B (7kg, 1000원)  | 불가능         |           | 0kg              |
| 총 금액          | **약 2,733원** |

- 이때 구한 총금액 (약 2,733원)은, 위 문제의 조건에서 얻을 수 있는 최대 금액이다.
- 위와 같이 무게당 금액이 가장 높은 짐부터 선택하면, 항상 최적해가 보장된다.
  - 얻을 수 있는 최대 금액을 구해야 하는 만큼, 무게당 금액이 더 낮은 짐을 선택할 이유가 없기 때문이다.

### 코드

```python
# (무게, 금액) 순
things = [(10, 1900), (6, 1000), (7, 1000)]
max_weight = 15
total_value = 0

# 무게당 금액이 높은 순으로 정렬
things.sort(key=lambda x: x[1] / x[0], reverse=True)

for weight, value in things:
    # 배낭에 공간이 남지 않은 경우
    if max_weight == 0:
        break

    # 안 쪼개고 다 넣을 수 있는 경우
    if weight <= max_weight:
        taken_weight = weight
        taken_value = value
    # 쪼개서 넣어야 하는 경우
    else:
        taken_weight = max_weight
        taken_value = value * (max_weight / weight)

    print(f"무게 {weight}kg, 금액 {value}원인 짐 중 {taken_weight}kg을 넣었습니다.")
    max_weight -= taken_weight
    total_value += taken_value
    print(f"남은 배낭 무게: {max_weight}")

print(f"총 금액: {total_value:.2f}원")

# 무게 10kg, 금액 1900원인 짐 중 10kg을 넣었습니다.
# 남은 배낭 무게: 5
# 무게 6kg, 금액 1000원인 짐 중 5kg을 넣었습니다.
# 남은 배낭 무게: 0
# 총 금액: 2733.33원
```

- 짐의 개수가 `K`개일 때, 위 코드의 시간 복잡도는 `O(K log K)`이다.
  - 정렬에 `O(K log K)`가 소요되고, 반복문으로 각 짐을 확인하며 `O(K)`가 소요된다.

## 그리디 알고리즘을 사용할 수 없는 경우

- **짐을 쪼개지 못하고** 모두 넣거나 아예 넣지 않아야 하는 경우, 문제의 최적해가 달라진다.

  - 이 경우, 짐 A가 10kg에 1,900원일 때, 무조건 10kg을 다 넣거나, 아예 넣지 말아야 한다.

- 앞선 예제처럼, A -> C -> B 순으로 무게당 금액이 높은 짐을 먼저 선택할 수 있다.

| 넣을 짐          | 넣은 무게   | 넣은 금액 | 배낭의 남은 무게 |
| ---------------- | ----------- | --------- | ---------------- |
| A (10kg, 1900원) | 10kg        | 1900원    | 15 - 10 = 5 kg   |
| C (6kg, 1000원)  | 불가능      |           | 5kg              |
| B (7kg, 1000원)  | 불가능      |           | 5kg              |
| 총 금액          | **1,900원** |

- 하지만 실제로는 B 7kg, C 6kg을 넣으면 2,000원을 넣을 수 있다. 무게도 13kg인 만큼 15kg을 초과하지 않는다.
  - 즉 그리디 알고리즘으로 구한 해 1,900원은 최적해가 아니다.
- 이럴 땐 동적 계획법을 사용해, 800원을 만들 수 있는 모든 조합을 분석해야 한다.

# 그리디 알고리즘의 사용 가능 조건

- 그리디 알고리즘은 주어진 문제가 **탐욕 선택 속성**과 **최적 부분 구조** 두 조건을 만족해야 사용할 수 있다.

## 탐욕 선택 속성 (Greedy Choice Problem)

- 문제에서 매 순간 탐욕적 선택을 해도, **나중에 문제의 최적해를 구하는 데 방해가 되지 않음**을 뜻한다.
- e.g., 1,260원을 500원, 100원, 50원, 10원으로 만들기
  - 제일 큰 단위인 500원 2개를 먼저 사용하고, 남은 금액도 계속 큰 단위 동전을 반복해 선택하면 최적해를 만들 수 있다.
- e.g., 800원을 500원, 400원, 100원으로 만들기
  - 제일 큰 단위인 500원 1개를 먼저 써 버리면, 400원 2개로 800원을 만들 수 없다.

## 최적 부분 구조 (Optimal Structure)

- 문제를 부분 문제로 나눴을 때, **각 부분 문제의 최적해를 합치면 전체 최적해**가 되어야 한다.
- e.g., 1,260원을 만드는 문제를, 700원 / 560원을 만드는 문제로 쪼갤 수 있다.
  - 700원 = 500원 1개, 100원 2개를 사용해, 총 동전 3개로 만들 수 있다.
  - 560원 = 500원 1개, 50원 2개, 10원 1개를 사용해, 총 동전 3개로 만들 수 있다.
  - 합쳐서 총 6개의 동전이 필요한데, 이는 1,260원을 만드는 문제의 최적해와 동일하다.

# 참고 자료

- [YouTube <동빈나> 채널 - (이코테 2021 강의 몰아보기) 2. 그리디 & 구현](https://www.youtube.com/watch?v=2zjoKjt97vQ)
- [박경록 - 코딩 테스트 합격자 되기 <파이썬 편>](https://goldenrabbit.co.kr/product/pythonpass/)
