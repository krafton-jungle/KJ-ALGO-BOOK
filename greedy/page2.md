## 문제.2 배낭 문제

### 문제 개요
- 배낭 문제는, 무게와 금액이 다른 짐들을 배낭에 넣는 문제이다.
- 이때 배낭이 담을 수 있는 최대 무게를 초과하지 않고서, 담은 짐들의 금액을 최대로 하는 방법을 찾아야 한다.
- 본 글에서는 아래와 같은 예제를 사용한다.

| 짐 번호        | 무게 | 금액    |
| -------------- | ---- | ------- |
| A              | 10kg | 1,900원 |
| B              | 7kg  | 1,000원 |
| C              | 6kg  | 1,000원 |
| 배낭 최대 무게 | 15kg |


### 코드 구현(Python)

```python
# (무게, 금액) 순
things = [(10, 1900), (6, 1000), (7, 1000)]
max_weight = 15
total_value = 0

# 무게당 금액이 높은 순으로 정렬
things.sort(key=lambda x: x[1] / x[0], reverse=True)

for weight, value in things:
    # 배낭에 공간이 남지 않은 경우
    if max_weight == 0:
        break

    # 안 쪼개고 다 넣을 수 있는 경우
    if weight <= max_weight:
        taken_weight = weight
        taken_value = value
    # 쪼개서 넣어야 하는 경우
    else:
        taken_weight = max_weight
        taken_value = value * (max_weight / weight)

    print(f"무게 {weight}kg, 금액 {value}원인 짐 중 {taken_weight}kg을 넣었습니다.")
    max_weight -= taken_weight
    total_value += taken_value
    print(f"남은 배낭 무게: {max_weight}")

print(f"총 금액: {total_value:.2f}원")

# 무게 10kg, 금액 1900원인 짐 중 10kg을 넣었습니다.
# 남은 배낭 무게: 5
# 무게 6kg, 금액 1000원인 짐 중 5kg을 넣었습니다.
# 남은 배낭 무게: 0
# 총 금액: 2733.33원
```

### 그리디 알고리즘을 사용할 수 있는 경우

- 짐을 **1kg 단위로 쪼갤 수 있는 경우**, 그리디 알고리즘으로 배낭 문제를 해결할 수 있다.

  - 예를 들어, 짐 A가 10kg에 1900원일 때, 5kg만 쪼개 넣을 수 있다.
  - 이때 짐의 금액은 전체 중 5kg에 해당하는 950원이 된다.

- 아래와 같은 절차를 따르면 된다.
  - **1단계** 짐별로 1kg당 금액을 구한다.
  - **2단계** 1kg당 금액이 가장 높은 짐부터 넣는다.
    - 배낭의 남은 무게가 충분한 경우, 짐 전체를 넣는다.
    - 배낭의 남은 무게가 짐의 무게보다 큰 경우, 넣을 수 있는 만큼만 쪼개 넣는다.
  - **3단계** 배낭이 다 찰 때까지 반복한다.
- 이 방식대로 위의 예제에 적용해 보자. 우선 3개의 짐에 대해, 1kg당 금액을 계산한다.

| 번호           | 무게 | 금액    | 1kg당 금액        |
| -------------- | ---- | ------- | ----------------- |
| A              | 10kg | 1,900원 | 1900 \ 10 = 190원 |
| B              | 7kg  | 1,000원 | 1000 \ 7 = 142원  |
| C              | 6kg  | 1,000원 | 1000 \ 6 = 166원  |
| 배낭 최대 무게 | 15kg |

- 1kg당 금액이 높은 **A(190) -> C(약 166) -> B(약 142)** 순으로 짐을 넣는다.
  - 이때 C의 경우 짐 전체를 넣기에는 배낭의 공간이 부족하므로, 6kg 중 5kg만 쪼개서 넣는다.

| 넣을 짐          | 넣은 무게      | 넣은 금액 | 배낭의 남은 무게 |
| ---------------- | -------------- | --------- | ---------------- |
| A (10kg, 1900원) | 10kg           | 1900원    | 15 - 10 = 5kg    |
| C (6kg, 1000원)  | 5kg            | 약 833원  | 5 - 5 = 0kg      |
| B (7kg, 1000원)  | 불가능         |           | 0kg              |
| 총 금액          | **약 2,733원** |

- 이때 구한 총금액 (약 2,733원)은, 위 문제의 조건에서 얻을 수 있는 최대 금액이다.
- 위와 같이 무게당 금액이 가장 높은 짐부터 선택하면, 항상 최적해가 보장된다.
  - 얻을 수 있는 최대 금액을 구해야 하는 만큼, 무게당 금액이 더 낮은 짐을 선택할 이유가 없기 때문이다.


- 짐의 개수가 `K`개일 때, 위 코드의 시간 복잡도는 `O(K log K)`이다.
  - 정렬에 `O(K log K)`가 소요되고, 반복문으로 각 짐을 확인하며 `O(K)`가 소요된다.


### 그리디 알고리즘을 사용할 수 없는 경우

- **짐을 쪼개지 못하고** 모두 넣거나 아예 넣지 않아야 하는 경우, 문제의 최적해가 달라진다.

  - 이 경우, 짐 A가 10kg에 1,900원일 때, 무조건 10kg을 다 넣거나, 아예 넣지 말아야 한다.

- 앞선 예제처럼, A -> C -> B 순으로 무게당 금액이 높은 짐을 먼저 선택할 수 있다.

| 넣을 짐          | 넣은 무게   | 넣은 금액 | 배낭의 남은 무게 |
| ---------------- | ----------- | --------- | ---------------- |
| A (10kg, 1900원) | 10kg        | 1900원    | 15 - 10 = 5 kg   |
| C (6kg, 1000원)  | 불가능      |           | 5kg              |
| B (7kg, 1000원)  | 불가능      |           | 5kg              |
| 총 금액          | **1,900원** |

- 하지만 실제로는 B 7kg, C 6kg을 넣으면 2,000원을 넣을 수 있다. 무게도 13kg인 만큼 15kg을 초과하지 않는다.
  - 즉 그리디 알고리즘으로 구한 해 1,900원은 최적해가 아니다.
- 이럴 땐 동적 계획법을 사용해, 800원을 만들 수 있는 모든 조합을 분석해야 한다.

## 그리디 알고리즘의 사용 가능 조건

- 그리디 알고리즘은 주어진 문제가 **탐욕 선택 속성**과 **최적 부분 구조** 두 조건을 만족해야 사용할 수 있다.

