## 트리란?

트리는 계층적인 구조를 시뮬레이션하는 **추상 자료형(Abstract Data Type)**으로, 
**루트 노드**를 중심으로 부모-자식 관계를 가진 **서브트리(Subtree)**들로 구성된 **노드의 집합이다.**

중심으로 정의한 개념구조를 말한다, 예를들어 스택이나 큐처럼 트리도 삽입, 탐색, 삭제 등

기능과 동작 중심으로 정의되며 실제 구현 방식은 배열, 연결리스트 등 여러 형태로 달라질 수 있다.

이 구조는 하나의 뿌리에서 위로 가지를 뻗는 모습과 닮았지만, 
**컴퓨터에서는 이를 반대로 표현**하여 루트가 위에, 자식들이 아래로 내려가는 방향으로 시각화한다. 
이런 구조 덕분에 트리는 **현실 세계의 위계 구조나 계층 관계**를 컴퓨터에서 효과적으로 표현할 수 있다.

예를 들어, **가계도(족보)**나 **회사 조직도**는 대표적인 트리 구조의 예시가 된다. 

루트는 조상이나 CEO가 되고, 자식 노드들은 후손이나 하위 부서로 표현됩니다.

트리의 가장 중요한 특성 중 하나는 **자기 참조적(self-referential) 구조**라는 점이다.
다시 말해, 트리는 자기 자신 안에 또 다른 트리를 포함하는 구조입니다. 
각각의 자식 노드는 또 하나의 트리이며, 이처럼 여러 트리가 반복적으로 구성되어 전체 트리를 형성하게 됩니다. 
이때 각 작은 트리를 **서브트리** 라고 부른다.

여기서 자기 참조적 구조란 자기자신과 같은 구조를 내부에 포함하거나 참조하는 구조를 의미한다, 

트리는 루트 노드와 서브트리들로 이루어져있으며 그 서브트리 또한 트리이기 때문에 자기 자신을 반복적으로 포함하는 형태가 된다.

이러한 구조덕분에 트리는 재귀적으로 정의 되며 트리 순회 구현 알고리즘도 자연스럽게 재귀적으로 구성된다.

## 트리의 각 명칭

트리 구조에서 사용되는 주요 용어들을 살펴보자.

트리는 **항상 루트 (Root)**에서 시작한다. 루트 노드는 하나 이상의 **자식 노드 (Child Node**)를 가질 수 있으며,
이들은 **간선 (Edge)**을 통해 서로 연결된다.

- **차수 (Degree)** : 노드가 가지는 자식 노드의 수를 의미한다. 예를 들어, 자식이 3개인 노드의 차수는 3이다.
- **크기 (Size)** : 해당 노드를 포함하여 그 하위 모든 자식 노드까지 합친 총 노드 수를 의미한다.
- **높이 (Height)** : 현재 노드에서 가장 먼 리프 노드(자식이 없는 노드)까지의 최대 거리(경로 길이)를 말한다.
- **깊이 (Depth)** : 루트 노드에서 현재 노드까지의 거리(경로 길이)를 의미한다.

이러한 명칭은 트리 구조를 분석하고 이해하는 데 필수적인 개념이다.

![이진트리구성](../assets/tree_concept/tree/Tree_Structure.png)



Figure 1. -트리 구성도

## 트리의 방향성과 레벨

트리에서 **레벨(Level)**은 일반적으로 **0부터 시작**한다. 루트 노드는 레벨 0이며, 그 자식은 레벨 1, 그 다음 자식은 레벨 2로 증가한다. 
**레벨을 0부터 시작하는 이유**는 **프로그래밍에서 인덱스를 0부터 세는 것이 일반적이기 때문**이다.

또한, 트리는 **항상 단방향 구조**이므로 **화살표를 생략해도 방향성을 이해할 수 있다.** 
일반적으로 트리는 **위에서 아래로** 향하는 방향으로 표현된다. 
루트에서 자식 노드로 내려가는 흐름을 시각적으로 쉽게 파악할 수 있도록 구성되어 있다.

## 그래프 vs 트리

트리와 그래프는 모두 노드와  간선으로 구성된 자료구조지만, **구조적 특성과 규칙**에서 분명한 차이가 있다.

가장 두드러지는 차이점은, **트리는 순환(Cycle)이 없는 그래프**라는 점이다. 
즉, 트리는 사이클이 존재하지 않는 비순환 그래프(Acyclic Graph)다. 
즉, **“사이클이 없다”는 점이 트리의 핵심적인 정의**다.

트리는 **그래프의 일종**이며, 넓은 범주로 보면 그래프에 포함된다. 
하지만 트리는 다음과 같은 **제약 조건**을 가진다.

- **트리에서는 한 번 연결된 노드가 다시 연결되는 경우가 없다.**
    
    즉, 어떤 경로를 따라가도 같은 노드를 두 번 방문할 수 없다.
    
- **트리는 단방향 구조**이며, 항상 **부모 노드 → 자식 노드**로의 방향만 존재한다.
    
    반면, 일반 그래프는 **단방향** 또는 **양방향** 모두를 허용한다.
    
- **모든 노드는 하나의 부모 노드만을 가진다.**
    
    예외는 루트 노드로, 루트는 **부모가 없는 유일한 노드**이다.
    
- 트리는 반드시 **하나의 루트 노드만 존재**해야 한다.
    
    루트에서 출발하여 다른 모든 노드에 도달할 수 있어야 한다.
    

![트리가아닌예](../assets/tree_concept/tree/Not_Tree_Ex.png)

Figure 2. 트리가 아닌 예

## 트리가 아닌 예시 분석

아래 그림은 **트리의 정의를 위반하는 세 가지 사례**를 보여주고 있다. 

각각이 왜 트리가 아닌지를 하나씩 분석해보자

### ① 사이클(순환 구조)

- 이 구조는 노드 간에 순환이 발생한다
- 앞서 설명했듯이 **트리는 사이클이 존재하지 않아야 하는 비 순환 그래프**이므로, 이 조건을 위반한다
- 따라서 이는 트리가 아니다

### ② 두 개의 부모 노드

- **C 노드가 A와 D 두 개의 부모를 가지고 있다.**
- 트리에서는 **모든 노드가 정확히 하나의 부모 노드만 가져야 하며**,

        루트만이 예외적으로 부모가 없어야 한다

- 이 규칙을 어겼기 때문에 트리 구조가 될 수 없다.

### ③ 루트가 둘, 연결되지 않은 구조

- **A→B**와 **C→D→E**가 **서로 연결되어 있지 않으며**, 두 개의 루트 노드(A, C)가 존재한다.
- 트리는 **하나의 루트에서 출발하여 모든 노드가 연결된 연결 그래프(Connected Graph)**이어야 하며, **루트 노드는 반드시 하나만 존재해야 한다.**
- 이 구조는 그 조건을 만족하지 않으므로 트리가 아니다.

---

> 지금까지 트리의 기본 개념과 특징, 그래프와의 차이점, 그리고 올바른 트리의 조건에 대해 알아보았다. 
트리는 데이터를 계층적으로 표현하고 탐색할 수 있는 매우 강력한 자료구조이다.
> 

> 하지만 우리가 실제로 다루는 데이터는 수천, 수만 개가 넘는 경우가 많다. 
단순한 트리 구조만으로는 이러한 대용량 데이터를 효율적으로 탐색하거나 저장하는 데 한계가 있다.
>