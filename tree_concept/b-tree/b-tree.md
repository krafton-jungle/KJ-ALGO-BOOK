# B-Tree

## B-Tree란?

B-Tree는 m-way 탐색 트리로, 디스크 기반 저장 시스템에서 **데이터 접근 속도를 최적화하기 위해 설계된** 균형 트리입니다.

주요 특징:
- 하나의 노드는 **여러 개의 키**와 **여러 자식 노드**를 가질 수 있어 트리의 **높이를 낮게 유지**할 수 있습니다.
- 주로 데이터베이스, 파일 시스템 등 **대용량 데이터**를 다루는 환경에서 사용됩니다.
- 항상 균형을 유지하므로 검색, 삽입, 삭제 연산에서 일관되고 효율적인 성능을 보장합니다.

## B-Tree 특징

1. 모든 **리프 노드는 동일한 깊이**를 가집니다.
2. 각 노드의 키는 **오름차순으로 정렬되어 저장**됩니다.
3. **하나의 노드에 여러 키**를 저장할 수 있어 디스크 접근 횟수가 줄고 성능이 향상됩니다.
4. **B-Tree 노드**는 최소 `⌈m/2⌉`개의 자식을 가져야 합니다.

## 노드의 키 / 자식 수 규칙 (B-Tree of order `m`)

- 각 노드는 **최대 `m`개의 자식**, **최대 `m - 1`개의 키**를 가질 수 있습니다.
- **최소 자식 수**: 루트를 제외한 모든 내부 노드는 최소 `⌈m / 2⌉`개의 자식을 가져야 합니다.
- **최소 키 수**:
  - 루트가 아닌 노드는 최소 `⌈m / 2⌉ - 1`개의 키를 가져야 합니다.
  - 루트 노드는 최소 **1개의 키**를 가져야 하며, **리프가 아닐 경우 최소 2개의 자식**을 가져야 합니다.
- **자식 수 = 키 수 + 1**의 관계를 가집니다. 즉, **키가 n-1개이면 자식은 n개**입니다.

## B-Tree의 시간 복잡도

`n`: B-트리에 저장된 전체 키의 수를 나타냅니다.

> B-Tree는 일반적인 이진 탐색 트리보다 높이가 낮기 때문에 실제 성능이 더 우수합니다.

| 연산 | 시간 복잡도 |
|------|------------|
| 검색(Search) | O(log n) |
| 삽입(Insert) | O(log n) |
| 삭제(Delete) | O(log n) |
| 순회(Traverse) | O(n) |

## B-Tree의 장단점

### 장점

- 항상 균형을 유지하므로 기본 연산이 O(log n) 시간에 수행됩니다.
- 높은 동시성과 처리량을 제공합니다.
- 디스크 공간을 효율적으로 활용할 수 있습니다.

### 단점

- 디스크 사용량이 많아질 수 있습니다.
- 데이터셋이 작을 경우, 이진 탐색 트리보다 비효율적일 수 있습니다.

## B-Tree의 활용

- 데이터베이스 인덱싱 (MySQL, PostgreSQL 등)
- 파일 시스템 (NTFS, HFS 등)
- 블록 기반 저장 장치의 검색 최적화
- 대규모 정렬 및 탐색 처리

## B-Tree의 탐색

B-Tree에서의 탐색은 이진 탐색 트리와 유사하게 동작합니다.

탐색할 키를 `k`라고 할 때, 다음과 같은 절차를 따릅니다:

1. 루트 노드에서 시작해 재귀적으로 내려갑니다.
2. 현재 노드에서 다음을 수행합니다:
   - 노드에 키 `k`가 존재하면 해당 노드를 반환합니다.
   - 키 `k`보다 큰 첫 번째 키 앞에 위치한 자식 노드로 이동합니다.
3. 리프 노드까지 반복합니다.
4. 리프 노드에 도달했으나 키를 찾지 못한 경우 NULL을 반환합니다.

B-Tree의 각 노드는 여러 개의 키를 포함하며, 키의 범위를 기준으로 탐색할 자식 노드를 결정합니다.
이때 키들은 분리 값(separation values) 역할을 하여 탐색 범위를 제한하고 탐색 효율을 높입니다.

## B-Tree의 삽입

B-Tree에서는 새로운 키를 **항상 리프 노드에 삽입**합니다.
루트 노드에서 시작하여 적절한 리프 노드로 내려갑니다.
노드마다 **삽입 전 가득 찼는지 확인**해야 합니다.

### 삽입 절차

1. 루트부터 시작하여 적절한 위치로 내려갑니다.
2. **내려가기 전**, 현재 노드가 **가득 찼는지 확인**합니다.
   - 가득 찼다면 `split_child()` 연산을 수행하여 노드를 분할합니다.
3. 리프 노드에 도달하면, 키를 **오름차순 정렬을 유지하며 삽입**합니다.

### split_child() 동작

- 가득 찬 자식 노드를 두 개로 분할합니다.
- 중간 키는 부모 노드로 이동하여 삽입됩니다.
- 삽입할 키가 분할된 두 노드 중 어느 쪽으로 가야 할지 판단하여, 적절한 자식 노드로 재귀적으로 삽입을 진행합니다.

## B-Tree의 삭제

B-Tree에서 삭제는 삽입보다 복잡합니다.
삭제 대상이 **내부 노드**에 있을 수 있어, **자식 노드의 재배치**가 필요합니다.
삭제 시에도 B-Tree의 **균형 조건**과 **최소 키 개수 조건**(t - 1)을 유지해야 합니다.

### 삭제의 세 가지 경우

#### Case 1: 키가 리프 노드에 존재하는 경우
- 단순히 해당 키를 제거합니다.

#### Case 2: 키가 내부 노드에 존재하는 경우
내부 노드에서 키 `k`를 삭제하려면 다음 중 하나를 수행합니다:

**2a.** `k`의 왼쪽 자식에 **t개 이상의 키**가 있는 경우
- `k`의 전임자 `k₀`를 찾아 `k`를 `k₀`로 대체하고, `k₀`를 재귀적으로 삭제합니다.

**2b.** `k`의 오른쪽 자식에 **t개 이상의 키**가 있는 경우
- `k`의 후임자 `k₀`를 찾아 `k`를 `k₀`로 대체하고, `k₀`를 재귀적으로 삭제합니다.

**2c.** 양쪽 자식(y, z) 모두 키가 `t-1`개뿐인 경우
- `k`, 왼쪽 자식, 오른쪽 자식을 병합하여 하나의 노드로 만들고, 병합된 노드에서 `k`를 재귀적으로 삭제합니다.

#### Case 3: 삭제할 키가 현재 노드에 없고 자식 노드로 내려가야 하는 경우
- 키가 포함될 가능성이 있는 자식 노드의 키 개수가 `t - 1`개라면, 먼저 **보강 작업**을 수행합니다.

**3a.** 형제 노드 중 하나에 **t개 이상 키가 있는 경우**
- 형제에게서 키를 하나 빌려와 현재 노드를 보강하고 하위로 내려갑니다.

**3b.** 현재 노드와 양쪽 형제가 모두 `t-1`개 키만 가진 경우
- 한 형제와 병합하고 중간 키를 내려보낸 뒤, 병합된 노드에서 재귀적으로 삭제를 진행합니다.

### 특이 케이스: 루트 노드가 비게 되는 경우
- 루트가 내부 노드이지만 키가 하나도 없게 되면, **유일한 자식 노드가 새 루트**가 되며, 트리의 **높이가 1 감소**합니다.

## 구현 코드

[btree.c](btree.c) 파일에서 전체 구현 코드를 확인할 수 있습니다. 