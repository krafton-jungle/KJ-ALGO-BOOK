# 힙 정렬 (Heap Sort)

이 장에서는 힙 정렬 알고리즘의 개념, 구현 방법, 그리고 실제 적용 예제를 중심으로 학습합니다.

> 이진 힙 구조를 활용하여 배열을 재배열하고 정렬하는 효율적인 힙 정렬 알고리즘을 학습할 수 있다.

## 목차

| 항목 | 설명 |
|------|------|
| [힙 정렬 알고리즘](#힙-정렬-알고리즘) | 힙 정렬의 전체적인 개요와 핵심 개념 설명 |
| [힙 정렬의 세부적인 작동 방식](#힙-정렬-절차) | 힙이 구성되고 정렬이 이루어지는 단계별 과정 |
| [힙 정렬 구현](#힙-정렬-코드-예시-python) | 파이썬으로 구현한 힙 정렬 예제 코드 |
| [힙 정렬에 대한 주요 특징](#힙-정렬의-주요-특징) | 알고리즘의 특성과 작동 방식의 핵심 요약 |
| [힙 정렬의 장점](#힙-정렬의-장점) | 힙 정렬이 가지는 이점과 효율성 |
| [힙 정렬의 단점](#힙-정렬의-단점) | 힙 정렬의 한계와 실제 사용 시 고려사항 |
| [참고](#참고) | 자료 출처 및 더 찾아보기 |

> 힙 정렬의 핵심인 이진 힙 구조와 heapify 과정을 단계별로 이해할 수 있도록 구성하였다.

## 핵심 키워드 정리

* **정의**: 이진 힙 자료구조를 이용해 최대값(또는 최소값)을 반복적으로 추출하며 정렬하는 알고리즘
* **자료구조**: 배열 (Array), 최대 힙 (Max Heap)
* **시간복잡도**: 모든 경우 `O(n log n)`
* **공간복잡도**: `O(1)` (제자리 정렬, 반복 기반일 경우)
* **동작 방식 요약**:
  * **입력**: 정렬되지 않은 배열
  * **처리**: 배열을 힙 구조로 변환 → 루트 노드를 끝으로 이동 → `heapify` 반복
  * **출력**: 정렬된 배열

## 힙 정렬이란

힙 정렬은 이진 힙에 기반한 정렬 알고리즘이다. 먼저 배열에서 최대(또는 최소) 요소를 찾아 마지막(또는 첫 번째) 요소와 교환한다. 이후 나머지 요소에 대해서도 같은 과정을 반복한다. 힙 정렬은 이진 힙을 사용함으로써 최대 요소를 O(n) 대신 O(log n)에 빠르게 찾고 이동할 수 있으므로, 전체 시간 복잡도는 O(n log n)이다. 

## 힙 정렬 알고리즘

먼저 `heapify` 과정을 통해 배열을 최대 힙으로 변환한다. 이 과정은 추가 메모리 없이 제자리에서 수행되며, 배열의 요소들이 힙 속성에 따라 재배열된다. 이후 최대 힙의 루트 노드를 하나씩 제거하고, 마지막 노드로 대체한 다음 다시 `heapify`를 수행한다. 힙의 크기가 1보다 클 때까지 반복하면 정렬이 완료된다.


## 힙 정렬 실행 과정

## 힙 정렬 절차

1. 배열의 요소를 재배열하여 최대 힙을 형성한다.  
2. 힙에 요소가 하나만 남을 때까지 다음 단계를 반복한다:  
   - 힙의 루트 요소(가장 큰 값)를 힙의 마지막 요소와 교환한다.  
   - 마지막 요소는 이제 정렬된 위치에 있으며, 힙 크기를 줄여 제외한다. 실제 배열에서 제거되지는 않는다.  
   - 나머지 힙 요소에 대해 다시 `heapify`를 수행하여 힙 구조를 유지한다.  
3. 모든 요소가 정렬된 위치에 도달하면, 최종적으로 정렬된 배열을 얻는다.

## 힙 정렬 과정

### 1단계: 배열을 완전 이진 트리로 간주한다  
배열을 완전 이진 트리로 시각화하여 힙 구조로 변환할 준비를 한다.  
크기가 `n`인 배열의 경우, 루트 노드는 인덱스 0에 위치하며,  
인덱스 `i`에 있는 노드의 왼쪽 자식은 `2i + 1`, 오른쪽 자식은 `2i + 2`에 위치한다.  
이러한 방식으로 배열을 완전 이진 트리로 해석할 수 있다.

![alt text](assets/sort/image.png)

### 2단계: 최대 힙을 구축한다  
`heapify` 과정을 통해 트리를 최대 힙의 구조로 만든다.  
이진 트리의 하위 노드부터 시작하여 각 서브트리에 대해 힙 속성을 만족시키도록 재정렬한다.  
최종적으로 부모 노드가 항상 자식 노드보다 크거나 같은 최대 힙이 형성된다.

### 3단계: 가장 큰 요소를 배열 끝으로 이동하여 정렬을 수행한다  
최대 힙의 루트 노드는 항상 가장 큰 값을 가지므로,  
이를 배열의 끝 요소와 교환한 후 힙에서 제외한다.  
그 후 남은 요소에 대해 다시 `heapify`를 수행하여 힙 구조를 유지한다.  
이 과정을 반복하면 가장 큰 값부터 차례로 정렬된 배열이 완성된다.

## 힙 정렬 코드 예시 (Python)

```python
def heapify(arr, n, i):
    largest = i 
    l = 2 * i + 1 
    r = 2 * i + 2  
    if l < n and arr[l] > arr[largest]:
        largest = l
    if r < n and arr[r] > arr[largest]:
        largest = r
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr) 
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0] 
        heapify(arr, i, 0)

def printArray(arr):
    for i in arr:
        print(i, end=" ")
    print()

arr = [9, 4, 3, 8, 10, 2, 5] 
heapSort(arr)
print("정렬된 배열은 ")
printArray(arr)
```

## 출력

```
정렬된 배열은
2 3 4 5 8 9 10
```

## 힙 정렬의 주요 특징

- **제자리(in-place) 정렬 알고리즘이다**.  
  별도의 추가 배열 없이 입력 배열 내에서 정렬을 수행한다.

- **일반적인 구현은 불안정하다**.  
  원소의 상대적 순서가 변경될 수 있으며, 특별한 구현을 통해 안정적으로 만들 수 있다.

- **퀵 정렬보다 일반적으로 느리다**.  
  참조 지역성(locality of reference)이 부족하여 캐시 효율이 낮고, 잘 구현된 퀵 정렬보다 2~3배 정도 느릴 수 있다.

## 힙 정렬의 장점

- **일관된 시간 복잡도**  
  모든 경우(최선, 평균, 최악)에서 시간 복잡도가 O(n log n)으로 일정하다.  
  이는 대용량 데이터셋을 처리할 때 안정적인 성능을 보장한다.

- **메모리 효율성**  
  반복적인 `heapify()`를 사용하면 재귀 호출에 필요한 스택 메모리를 줄일 수 있다.  
  추가적인 메모리 공간 없이 동작이 가능하다.

- **구현의 단순성**  
  재귀와 같은 고급 개념 없이도 구현할 수 있어 상대적으로 이해하기 쉽다.

## 힙 정렬의 단점

- **낮은 실사용 성능**  
  같은 시간 복잡도를 가지는 병합 정렬보다 상수가 크기 때문에 실제로는 느릴 수 있다.

- **불안정성**  
  동일한 값을 가진 원소들의 상대적 순서가 보장되지 않는다.

- **참조 지역성 부족**  
  배열 접근이 비연속적으로 일어나기 때문에 캐시 효율이 낮아 실행 시간이 증가할 수 있다.

## 참고

- 참고한 자료
  - GeeksforGeeks의 [Heap Sort](https://www.geeksforgeeks.org/heap-sort/)
- 이미지 출처
  - https://www.geeksforgeeks.org/heap-sort/